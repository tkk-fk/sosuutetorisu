<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,maximum-scale=1.0,user-scalable=no" />
<title>素数テトリス（ポップアップ豆知識＋不具合修正）</title>
<style>
  :root{
    --cell: clamp(22px, 7vw, 36px);
    --btn: clamp(40px, 7.5vw, 46px);
  }
  *{ box-sizing:border-box; -webkit-tap-highlight-color:transparent; }
  body{
    font-family: system-ui, -apple-system, "BIZ UDGothic", Arial, sans-serif;
    background:#0f172a; color:#fff; margin:0; padding:12px;
    display:flex; flex-direction:column; align-items:center;
  }
  h1{ margin:6px 0 2px; font-size:clamp(18px,5vw,24px); }
  #info{ margin:6px 0 10px; font-size:1rem; display:flex; gap:14px; align-items:center; flex-wrap:wrap; }

  #topbar{
    display:flex; gap:8px; flex-wrap:wrap; justify-content:center; margin:8px 0;
  }
  .tbtn{
    background:#22d3ee; color:#062029; border:none; padding:8px 12px;
    border-radius:10px; font-weight:900; cursor:pointer; font-size:clamp(14px,3.6vw,16px);
    box-shadow: 0 4px 14px #00000040;
  }
  .tbtn.secondary{ background:#334155; color:#d7e5ff; }

  #game-container{
    border:4px solid #38bdf8; background:#000; display:inline-block; margin-top:6px;
    box-shadow: 0 12px 32px #00000055; border-radius:12px; overflow:hidden;
  }
  .row{ display:flex; }
  .cell{
    width:var(--cell); height:var(--cell); border:1px solid #1f2937; display:flex;
    justify-content:center; align-items:center; font-weight:800; font-size:calc(var(--cell) * 0.6);
    user-select:none; transform-origin:center; color:#fff; background:#334155;
  }
  /* 数字色 */
  .cell.d1{ background:#3b82f6; }  .cell.d2{ background:#10b981; }  .cell.d3{ background:#ef4444; }
  .cell.d4{ background:#f59e0b; }  .cell.d5{ background:#a855f7; }  .cell.d6{ background:#14b8a6; }
  .cell.d7{ background:#ec4899; }  .cell.d8{ background:#6366f1; }  .cell.d9{ background:#f97316; }

  .active{ outline:2px solid #ffffffaa; }
  .fixed{ outline:1px solid #00000040; }

  /* 消しゴム（"消"） */
  .eraser{
    background:#f5f5f5 !important; color:#111 !important;
    border:2px dashed #ef4444 !important;
    background-image: repeating-linear-gradient(45deg, #fff 0 6px, #ffe4e6 6px 12px) !important;
  }

  /* 消去アニメ：点滅→ポップアウト */
  .blink{ animation: blink .12s ease-in-out 3; }
  @keyframes blink{
    0%,100%{ filter:none; transform:scale(1); }
    50%{ filter:brightness(2); transform:scale(1.06); box-shadow:0 0 10px #eab308aa; }
  }
  .clearing{
    animation: popout .22s ease-out forwards;
    box-shadow: 0 0 10px #fca5a5, 0 0 18px #fdba74;
    background:#fb923c !important;
  }
  @keyframes popout{
    0%{ transform: scale(1); opacity:1; }
    60%{ transform: scale(1.15); opacity:.9; }
    100%{ transform: scale(0.1); opacity:0; }
  }

  /* 連鎖バッジ */
  #chainBadge{
    display:inline-block; padding:2px 8px; border-radius:999px;
    background:#22c55e; color:#04210f; font-weight:900; font-size:0.9rem; min-width:64px; text-align:center;
    visibility:hidden;
  }

  /* 操作パッド（PC:上部、SP:下部固定） */
  .controls{
    margin-top:10px; display:flex; gap:8px; flex-wrap:wrap; justify-content:center;
  }
  .btn{
    min-width:70px; height:var(--btn);
    background:#38bdf8; color:#05222c; border:none; padding:8px 12px;
    border-radius:12px; font-weight:900; cursor:pointer; font-size:clamp(14px,3.8vw,16px);
    box-shadow: 0 6px 18px #00000044;
  }
  .btn.gray{ background:#334155; color:#e2e8f0; }
  .btn.red{ background:#fb7185; color:#2b0c12; }

  /* 消えた素数の履歴（数値だけをバッジ表示） */
  #clearedPanel{
    margin-top:12px; padding:10px; border:2px solid #38bdf8; background:#0b1220;
    max-width:min(96vw, 560px); width:100%; border-radius:12px;
  }
  #clearedPanel h2{ margin:0 0 8px; font-size:14px; font-weight:800; color:#cde9ff; }
  #clearedList{
    display:flex; gap:6px; flex-wrap:wrap; max-height:140px; overflow:auto;
  }
  .primeTag{
    background:#0ea5e9; color:#002233; font-weight:900;
    border-radius:999px; padding:4px 10px; font-size:14px;
    box-shadow: 0 2px 6px #00000033; display:inline-flex; align-items:center;
  }

  /* 素数一覧モーダル（既存） */
  #primeModal{ position:fixed; inset:0; background:rgba(0,0,0,.6); display:none; place-items:center; padding:16px; z-index:9999; }
  #primeModal.show{ display:grid; }
  .modalCard{
    width:min(96vw, 720px); max-height:86vh; overflow:hidden;
    background:#0b1220; border:2px solid #38bdf8; border-radius:16px; box-shadow:0 20px 60px #000000aa;
    display:flex; flex-direction:column;
  }
  .modalHead{ padding:10px; display:flex; gap:8px; align-items:center; flex-wrap:wrap; border-bottom:1px solid #1f2a44; }
  .modalHead h3{ margin:0; font-size:16px; }
  .modalBody{ padding:10px; overflow:auto; display:flex; flex-wrap:wrap; gap:6px; }
  .modalFoot{ padding:10px; border-top:1px solid #1f2a44; display:flex; gap:8px; justify-content:flex-end; }
  .tag{ background:#1f2937; color:#cde9ff; border-radius:999px; padding:4px 10px; font-weight:800; }

  /* モバイル：操作パッド下部固定 */
  @media (max-width: 680px){
    .controls{
      position:fixed; left:50%; transform:translateX(-50%);
      bottom:8px; background:#0b1220e6; backdrop-filter: blur(6px);
      padding:8px; border-radius:14px; width:calc(100vw - 16px);
      display:grid; grid-template-columns: repeat(5, 1fr); gap:6px;
      z-index:999;
    }
    #game-container{ margin-bottom:calc(var(--btn) * 2 + 28px); }
    .btn{ min-width:unset; }
  }

  /* ポップアップ（豆知識） */
  #toastArea{
    position:fixed; left:0; right:0; top:64px; display:flex; justify-content:center; gap:8px;
    pointer-events:none; z-index:9999;
  }
  .toast{
    background:#22c55e; color:#052a13; font-weight:900; font-size:14px;
    padding:6px 10px; border-radius:999px; box-shadow:0 6px 18px #00000055;
    transform:translateY(-8px); opacity:0; animation: toastIn .12s ease-out forwards;
  }
  @keyframes toastIn{
    to{ transform:translateY(0); opacity:1; }
  }
</style>
</head>
<body>

<h1>素数テトリス</h1>

<div id="topbar">
  <button class="tbtn" id="startToggle">▶︎ スタート</button>
  <button class="tbtn secondary" id="openPrime">📜 素数一覧</button>
  <span id="chainBadge">Chain x1</span>
</div>

<div id="info">
  <span>スコア: <strong id="score">0</strong></span>
  <span>ハイスコア: <strong id="hiscore">0</strong></span>
</div>

<div id="game-container"></div>

<div class="controls" id="controls">
  <button class="btn gray" id="left">◀︎</button>
  <button class="btn gray" id="down">⤵︎</button>
  <button class="btn gray" id="right">▶︎</button>
  <button class="btn" id="rotL">⟲</button>
  <button class="btn" id="rotR">⟳</button>
  <button class="btn" id="hard">⏬</button>
  <button class="btn red" id="reset">⟲ リセット</button>
</div>

<div id="clearedPanel">
  <h2>消えた素数</h2>
  <div id="clearedList" aria-live="polite"></div>
</div>

<!-- ポップアップ表示領域 -->
<div id="toastArea" aria-live="polite"></div>

<!-- 素数一覧モーダル（省略説明：既存機能） -->
<div id="primeModal" role="dialog" aria-modal="true" aria-labelledby="primeTitle">
  <div class="modalCard">
    <div class="modalHead">
      <h3 id="primeTitle">素数一覧（最大10桁）</h3>
      <span class="tag">桁:</span>
      <select id="digitSel" class="tbtn secondary" style="padding:6px 10px;">
        <option>1</option><option>2</option><option>3</option><option>4</option><option>5</option>
        <option>6</option><option>7</option><option>8</option><option>9</option><option selected>10</option>
      </select>
      <span class="tag">1回の表示:</span>
      <select id="batchSel" class="tbtn secondary" style="padding:6px 10px;">
        <option>50</option><option>100</option><option selected>200</option><option>500</option>
      </select>
      <button class="tbtn" id="moreBtn">もっと表示</button>
      <button class="tbtn secondary" id="resetListBtn">最初から</button>
    </div>
    <div id="primeListBox" class="modalBody"></div>
    <div class="modalFoot">
      <button class="tbtn" id="closePrime">閉じる</button>
    </div>
  </div>
</div>

<script>
  // ====== 設定 ======
  const ROWS = 20, COLS = 10, TICK = 550;
  const SCORE_CELL = 50, SCORE_GROUP = 100;

  const ERASER = -1, ERASER_RATE = 0.10, ERASER_RADIUS = 1, ERASER_FACE = '消';

  const SHAPES = [
    [[1,1,1,1]], [[1,1],[1,1]], [[1,1,1],[0,1,0]],
    [[0,1,1],[1,1,0]], [[1,1,0],[0,1,1]],
    [[1,1,1],[0,0,1]], [[1,1,1],[1,0,0]],
  ];

  const container = document.getElementById('game-container');
  const scoreEl = document.getElementById('score');
  const hiscoreEl = document.getElementById('hiscore');
  const chainBadge = document.getElementById('chainBadge');
  const clearedListEl = document.getElementById('clearedList');
  const toastArea = document.getElementById('toastArea');

  const startToggleBtn = document.getElementById('startToggle');
  const primeModal = document.getElementById('primeModal');
  const openPrimeBtn = document.getElementById('openPrime');
  const closePrimeBtn = document.getElementById('closePrime');
  const moreBtn = document.getElementById('moreBtn');
  const resetListBtn = document.getElementById('resetListBtn');
  const digitSel = document.getElementById('digitSel');
  const batchSel = document.getElementById('batchSel');
  const primeListBox = document.getElementById('primeListBox');

  let board, active, timer=null, score=0, highScore=0, busy=false, running=false, wasRunning=false;
  let audioCtx = null;
  let clearedHistory = []; // 純粋に数だけ

  // ====== 基本ユーティリティ ======
  function randDigit(){ return Math.floor(Math.random()*9)+1; }
  function isPrime(n){
    if(n<=1) return false;
    if(n<=3) return true;
    if(n%2===0 || n%3===0) return n===2 || n===3;
    for(let i=5;i*i<=n;i+=6){
      if(n%i===0 || n%(i+2)===0) return false;
    }
    return true;
  }
  const delay = ms => new Promise(res=>setTimeout(res, ms));

  // ====== オーディオ ======
  function ensureAudio(){
    audioCtx = audioCtx || new (window.AudioContext||window.webkitAudioContext)();
    if(audioCtx.state==='suspended') audioCtx.resume();
  }
  function playClearSE(chain=1){
    try{
      ensureAudio();
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = 'square';
      const base = 520, step = 110;
      o.frequency.value = base + step*(chain-1);
      g.gain.value = 0.08;
      o.connect(g).connect(audioCtx.destination);
      o.start();
      g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime+0.16);
      o.stop(audioCtx.currentTime+0.17);
    }catch(e){}
  }
  function playEraserSE(){
    try{
      ensureAudio();
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = 'triangle'; o.frequency.value = 420; g.gain.value = 0.1;
      o.connect(g).connect(audioCtx.destination); o.start();
      g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime+0.12);
      o.stop(audioCtx.currentTime+0.13);
    }catch(e){}
  }

  // ====== 盤・初期化 ======
  function buildGrid(){
    container.innerHTML = '';
    for(let r=0;r<ROWS;r++){
      const row = document.createElement('div'); row.className='row'; row.id = `row-${r}`;
      for(let c=0;c<COLS;c++){
        const cell = document.createElement('div'); cell.className='cell'; cell.id=`cell-${r}-${c}`;
        row.appendChild(cell);
      }
      container.appendChild(row);
    }
  }

  const HS_KEY = 'prime_tetris_hiscore_v1';
  function loadHighScore(){
    highScore = Number(localStorage.getItem(HS_KEY) || 0);
    hiscoreEl.textContent = highScore;
  }
  function updateHighScore(){
    if(score > highScore){
      highScore = score;
      localStorage.setItem(HS_KEY, String(highScore));
      hiscoreEl.textContent = highScore;
    }
  }

  function init(){
    board = Array.from({length:ROWS}, ()=>Array(COLS).fill(0));
    score = 0; scoreEl.textContent = 0;
    chainBadge.style.visibility = 'hidden';
    clearedHistory = []; renderCleared();
    buildGrid();
    loadHighScore();
    spawn();
    draw();
    stop(); // 初期は停止
  }

  // ====== ピース生成 ======
  function randomPiece(){
    if(Math.random() < ERASER_RATE){
      return { type:'eraser', cells:[[ERASER]] };
    }
    const mask = SHAPES[Math.floor(Math.random()*SHAPES.length)];
    return { type:'digits', cells: mask.map(row => row.map(v => v ? randDigit() : 0)) };
  }

  function spawn(){
    const p = randomPiece();
    const h = p.cells.length, w = p.cells[0].length;
    const x = Math.floor(COLS/2 - w/2), y = 0;
    active = { x, y, cells:p.cells, type:p.type };
    if(!canPlace(x, y, active.cells)){
      stop();
      alert(`ゲームオーバー！ スコア: ${score}`);
      init();
    }
  }

  // ====== 変換/判定 ======
  function rotateCW(mat){
    const h = mat.length, w = mat[0].length;
    const out = Array.from({length:w},()=>Array(h).fill(0));
    for(let r=0;r<h;r++) for(let c=0;c<w;c++) out[c][h-1-r] = mat[r][c];
    return out;
  }
  function rotateCCW(mat){
    const h = mat.length, w = mat[0].length;
    const out = Array.from({length:w},()=>Array(h).fill(0));
    for(let r=0;r<h;r++) for(let c=0;c<w;c++) out[w-1-c][r] = mat[r][c];
    return out;
  }
  function canPlace(px, py, cells){
    const h = cells.length, w = cells[0].length;
    for(let r=0;r<h;r++){
      for(let c=0;c<w;c++){
        if(cells[r][c]===0) continue;
        const x = px + c, y = py + r;
        if(x<0 || x>=COLS || y<0 || y>=ROWS) return false;
        if(board[y][x]!==0) return false;
      }
    }
    return true;
  }

  // ====== ロック＆連鎖（★再開バグ修正あり） ======
  async function lock(){
    // 固定（数字のみ）。消しゴムは効果だけ。
    const erasers = [];
    const h = active.cells.length, w = active.cells[0].length;
    for(let r=0;r<h;r++){
      for(let c=0;c<w;c++){
        const v = active.cells[r][c];
        if(v===0) continue;
        const y = active.y + r, x = active.x + c;
        if(y<0 || y>=ROWS || x<0 || x>=COLS) continue;
        if(v===ERASER){ erasers.push({x,y}); } else { board[y][x] = v; }
      }
    }
    if(erasers.length){
      erasers.forEach(({x,y}) => eraseArea(x,y));
      playEraserSE(); draw(true); await delay(40);
    }

    // 連鎖：現在の稼働状態を保持→停止（★ここが修正点）
    const resumeAfter = running;
    stop(); busy = true;
    let chain = 0;

    while(true){
      const res = computeClearMask(); // {mask,cellsCleared,groups,primes}
      if(res.cellsCleared === 0) break;
      chain++;
      chainBadge.textContent = `Chain x${chain}`;
      chainBadge.style.visibility = 'visible';

      // ★分類タグ（回文/エミルプ/双子/ソフィーG/セーフ）を集約（重複除去）
      const tagSet = new Set();
      for(const n of res.primes){ classifyPrime(n).forEach(t=>tagSet.add(t)); }
      await animateClear(res.mask, chain, Array.from(tagSet)); // 点滅→消滅＋ポップアップ

      // 反映
      let cleared = 0;
      for(let r=0;r<ROWS;r++){
        for(let c=0;c<COLS;c++){
          if(res.mask[r][c]){ board[r][c]=0; cleared++; }
        }
      }
      score += cleared*SCORE_CELL + res.groups*SCORE_GROUP;
      scoreEl.textContent = score;
      updateHighScore();

      // 履歴は数値のみを保存
      if(res.primes.length){
        clearedHistory = [...res.primes, ...clearedHistory].slice(0, 60);
        renderCleared();
      }

      applyGravity();
      draw(true);
      await delay(60);
    }
    chainBadge.style.visibility = 'hidden';
    busy = false;
    spawn();
    if(resumeAfter) start(); // ★連鎖前に動いていたら再開
  }

  function eraseArea(cx, cy){
    for(let dy=-ERASER_RADIUS; dy<=ERASER_RADIUS; dy++){
      for(let dx=-ERASER_RADIUS; dx<=ERASER_RADIUS; dx++){
        const x = cx+dx, y = cy+dy;
        if(x>=0 && x<COLS && y>=0 && y<ROWS){
          if(board[y][x]!==0) board[y][x]=0;
        }
      }
    }
  }

  // ラン全体が素数 + 1桁素数(2,3,5,7)
  function computeClearMask(){
    const mask = Array.from({length:ROWS}, ()=>Array(COLS).fill(false));
    let groups = 0, cellsCleared = 0, primes = [];

    for(let r=0;r<ROWS;r++){
      let c = 0;
      while(c<COLS){
        while(c<COLS && board[r][c]===0) c++;
        if(c>=COLS) break;

        const start = c;
        const digits = [];
        while(c<COLS && board[r][c]!==0){ digits.push(board[r][c]); c++; }
        const end = c-1;
        const len = digits.length;

        if(len===1){
          if(isPrime(digits[0])){
            if(!mask[r][start]){ mask[r][start]=true; cellsCleared++; }
            groups++; primes.push(digits[0]);
          }
        }else if(len>=2){
          let val = 0;
          for(let i=0;i<len;i++) val = val*10 + digits[i];
          if(isPrime(val)){
            for(let x=start; x<=end; x++){
              if(!mask[r][x]){ mask[r][x]=true; cellsCleared++; }
            }
            groups++; primes.push(val);
          }
        }
      }
    }
    return {mask, cellsCleared, groups, primes};
  }

  // ====== 点滅→消滅＋ポップアップ（0.1秒） ======
  async function animateClear(mask, chain, labels=[]){
    draw(true);

    // 点滅
    for(let r=0;r<ROWS;r++){
      for(let c=0;c<COLS;c++){
        if(mask[r][c]){
          const el = document.getElementById(`cell-${r}-${c}`);
          if(el){ el.classList.add('blink'); }
        }
      }
    }
    playClearSE(chain);
    await delay(360); // 0.12s * 3

    // ★豆知識ポップアップ（0.1s、複数あれば順に少しずらして表示）
    if(labels.length){
      labels.slice(0,5).forEach((txt, i)=>{
        setTimeout(()=>showToast(`${txt}！`, 110), i*120);
      });
    }

    // 消滅
    for(let r=0;r<ROWS;r++){
      for(let c=0;c<COLS;c++){
        if(mask[r][c]){
          const el = document.getElementById(`cell-${r}-${c}`);
          if(el){ el.classList.remove('blink'); el.classList.add('clearing'); }
        }
      }
    }
    await delay(230);
  }

  function showToast(text, ms=110){
    const d = document.createElement('div');
    d.className = 'toast';
    d.textContent = text;
    toastArea.appendChild(d);
    setTimeout(()=>{ d.remove(); }, ms);
  }

  // 重力
  function applyGravity(){
    for(let c=0;c<COLS;c++){
      const stack = [];
      for(let r=ROWS-1;r>=0;r--) if(board[r][c]!==0) stack.push(board[r][c]);
      for(let r=ROWS-1;r>=0;r--){
        board[r][c] = stack[ROWS-1-r] ?? 0;
      }
    }
  }

  // ====== 描画・入力 ======
  function step(){
    if(busy || !running) return;
    if(canPlace(active.x, active.y+1, active.cells)) active.y++;
    else lock();
    draw();
  }
  function start(){ stop(); timer=setInterval(step, TICK); running=true; startToggleBtn.textContent='⏸ ポーズ'; }
  function stop(){ if(timer){ clearInterval(timer); timer=null; } running=false; startToggleBtn.textContent='▶︎ スタート'; }

  function move(dx){
    if(busy || !running) return;
    const nx = active.x + dx;
    if(canPlace(nx, active.y, active.cells)){ active.x = nx; draw(); }
  }
  function soft(){
    if(busy || !running) return;
    if(canPlace(active.x, active.y+1, active.cells)) active.y++;
    else lock();
    draw();
  }
  function hard(){
    if(busy || !running) return;
    while(canPlace(active.x, active.y+1, active.cells)) active.y++;
    lock();
  }

  function renderCleared(){
    clearedListEl.innerHTML = '';
    for(const n of clearedHistory){
      const tag = document.createElement('span');
      tag.className = 'primeTag';
      tag.textContent = n;
      clearedListEl.appendChild(tag);
    }
  }

  function draw(skipActive=false){
    for(let r=0;r<ROWS;r++){
      for(let c=0;c<COLS;c++){
        const el = document.getElementById(`cell-${r}-${c}`);
        el.textContent = '';
        el.className = 'cell';
        if(board[r][c]!==0){
          const v = board[r][c];
          el.textContent = v;
          el.classList.add('fixed', `d${v}`);
        }
      }
    }
    if(skipActive) return;
    const h = active.cells.length, w = active.cells[0].length;
    for(let r=0;r<h;r++){
      for(let c=0;c<w;c++){
        const v = active.cells[r][c];
        if(v===0) continue;
        const y = active.y + r, x = active.x + c;
        if(y>=0 && y<ROWS && x>=0 && x<COLS){
          const el = document.getElementById(`cell-${y}-${x}`);
          if(v===ERASER){
            el.textContent = ERASER_FACE;
            el.classList.add('active','eraser');
            el.style.fontSize = 'calc(var(--cell)*0.6)';
          }else{
            el.textContent = v;
            el.classList.add('active', `d${v}`);
          }
        }
      }
    }
  }

  // 豆知識の判定
  function isPalindromeStr(s){ return s === [...s].reverse().join(''); }
  function isProbablePrimeMR(n){
    if(n < 2) return false;
    const small = [2,3,5,7,11,13,17,19,23,29,31,37];
    for(const p of small){
      if(n === p) return true;
      if(n % p === 0) return false;
    }
    const bN = BigInt(n);
    let d = bN - 1n, s = 0n;
    while((d & 1n) === 0n){ d >>= 1n; s++; }
    const bases = [2n,3n,5n,7n,11n];
    for(const a of bases){
      if(a >= bN) continue;
      let x = modPow(a, d, bN);
      if(x === 1n || x === bN-1n) continue;
      let comp = true;
      for(let r=1n; r<s; r++){
        x = (x*x) % bN;
        if(x === bN-1n){ comp = false; break; }
      }
      if(comp) return false;
    }
    return true;
  }
  function modPow(a, e, m){
    let res = 1n % m, base = a % m, exp = e;
    while(exp > 0n){
      if(exp & 1n) res = (res * base) % m;
      base = (base*base) % m; exp >>= 1n;
    }
    return res;
  }
  function classifyPrime(n){
    const tags = [];
    const s = String(n);
    if(isPalindromeStr(s)) tags.push('回文');
    const rev = Number([...s].reverse().join(''));
    if(rev !== n && isProbablePrimeMR(rev)) tags.push('エミルプ');
    if(isProbablePrimeMR(n-2) || isProbablePrimeMR(n+2)) tags.push('双子');
    if(isProbablePrimeMR(2*n + 1)) tags.push('ソフィーG');
    if(n % 2 === 1 && isProbablePrimeMR((n-1)/2)) tags.push('セーフ');
    if(n < 10) tags.push('1桁');
    return tags;
  }

  // 入力
  document.addEventListener('keydown', (e)=>{
    if(['ArrowLeft','ArrowRight','ArrowDown',' ','ArrowUp','x','X','z','Z'].includes(e.key)) e.preventDefault();
    switch(e.key){
      case 'ArrowLeft': move(-1); break;
      case 'ArrowRight': move(1); break;
      case 'ArrowDown': soft(); break;
      case ' ': hard(); break;
      case 'ArrowUp':
      case 'x': case 'X': if(!busy) tryRotate(1); break;
      case 'z': case 'Z': if(!busy) tryRotate(-1); break;
      case 'r': case 'R': stop(); init(); break;
    }
  });

  document.getElementById('left').onclick = ()=>move(-1);
  document.getElementById('right').onclick= ()=>move(1);
  document.getElementById('down').onclick = soft;
  document.getElementById('hard').onclick = hard;
  document.getElementById('rotR').onclick = ()=>{ if(!busy) tryRotate(1); };
  document.getElementById('rotL').onclick = ()=>{ if(!busy) tryRotate(-1); };
  document.getElementById('reset').onclick= ()=>{ stop(); init(); };

  // スタート/ポーズ
  function start(){ stop(); timer=setInterval(step, TICK); running=true; startToggleBtn.textContent='⏸ ポーズ'; }
  function stop(){ if(timer){ clearInterval(timer); timer=null; } running=false; startToggleBtn.textContent='▶︎ スタート'; }
  startToggleBtn.onclick = ()=>{
    ensureAudio();
    if(running) stop(); else start();
  };

  // ===== 素数一覧（既存） =====
  let primeCursor = {};
  openPrimeBtn.onclick = ()=>{
    wasRunning = running; stop();
    primeModal.classList.add('show');
    if(!primeCursor[digitSel.value]) resetPrimeList();
  };
  closePrimeBtn.onclick = ()=>{
    primeModal.classList.remove('show');
    if(wasRunning) start();
  };
  resetListBtn.onclick = resetPrimeList;
  moreBtn.onclick = ()=> appendBatch();
  digitSel.onchange = resetPrimeList;

  function resetPrimeList(){
    primeListBox.innerHTML = '';
    const d = parseInt(digitSel.value,10);
    primeCursor[d] = Math.max(2, 10**(d-1));
    appendBatch();
  }
  async function appendBatch(){
    const d = parseInt(digitSel.value,10);
    const batch = parseInt(batchSel.value,10);
    const upper = 10**d - 1;
    let n = primeCursor[d] ?? Math.max(2, 10**(d-1));
    let found = 0; const frag = document.createDocumentFragment();
    if(n<=2 && 2>=10**(d-1) && 2<=upper){ frag.appendChild(makePrimeTag(2)); found++; n = 3; }
    if(n%2===0) n++;
    while(found < batch && n <= upper){
      if(isProbablePrimeMR(n)){ frag.appendChild(makePrimeTag(n)); found++; }
      n += 2;
      if(n % 2001 === 1) await delay(0);
    }
    primeListBox.appendChild(frag);
    primeCursor[d] = n;
  }
  function makePrimeTag(n){
    const sp = document.createElement('span');
    sp.className = 'primeTag'; sp.textContent = n.toString(); return sp;
  }

  // 回転（壁蹴り）
  function tryRotate(dir=1){
    if(busy || active.type==='eraser') return;
    const rotated = dir===1 ? rotateCW(active.cells) : rotateCCW(active.cells);
    const kicks = [[0,0],[1,0],[-1,0],[2,0],[-2,0]];
    for(const [dx,dy] of kicks){
      if(canPlace(active.x+dx, active.y+dy, rotated)){
        active.cells = rotated; active.x += dx; active.y += dy; draw(); return;
      }
    }
  }

  // 起動
  buildGrid(); init();
</script>
</body>
</html>
